{"data":{"site":{"siteMetadata":{"siteUrl":"https://nerds-den.com","facebook":{"appId":"2232544823425455"}}},"post":{"id":"43a6a365-af64-5524-bd44-83ad69e8e90a","excerpt":"Over three years, I worked as a Backend Team Lead at  Elanic   (India‚Äôs Biggest Community For Buying and Selling).  I learned a lot about‚Ä¶","html":"<p>Over three years, I worked as a Backend Team Lead at <a href=\"https://elanic.in\">Elanic</a> <em>(India‚Äôs Biggest Community For Buying and Selling).</em> I learned a lot about software development during these ‚Äúfirey‚Äù years of scaling\n<a href=\"https://elanic.in\">Elanic</a> from 3 users in August 2015 to 3 million users in August 2018.</p>\n<p>I started with no prior experience in building a production-grade software system. I thought I had a good foundation of programming concepts. How hard could it be? Little that I knew, I am in for lots of sleepless nights and burning myself out in the quest of stabilizing Elanic‚Äôs backend system.</p>\n<blockquote>\n<p>Trying to create new, challenging things is good for society, good for the industry and good for my own life. ~Sachio Semmoto</p>\n</blockquote>\n<p>No other experience could have taught me what I know today. In this article, I share my experiences and the software design lessons I learned the hard way.</p>\n<hr>\n<h3>Table Of Contents</h3>\n<ol>\n<li><a href=\"#start-with-the-data-model\">Start With The Data Model</a></li>\n<li><a href=\"#separate-your-concerns\">Separate Your Concerns</a></li>\n<li><a href=\"#leverage-rule-engines\">Leverage Rule Engines</a></li>\n<li><a href=\"#prioritize-software-testing\">Prioritize Software Testing</a></li>\n<li><a href=\"#there-will-always-be-bugs\">There Will Always Be Bugs</a></li>\n<li><a href=\"#things-will-break\">Things Will Break</a></li>\n<li><a href=\"#setup-logging-and-error-handling\">Setup Logging And Error Handling Early</a></li>\n<li><a href=\"#it-will-take-longer-than-you-think\">It Will Take Longer Than You Think</a></li>\n<li><a href=\"#there-are-no-coincidences\">There Are No Coincidences</a></li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ol>\n<p><a name=\"start-with-the-data-model\"></a></p>\n<hr>\n<h3>1. Start With The Data Model</h3>\n<p>Business people often care about data and concentrate on how this data can be transformed, combined and separated to meet business requirements.</p>\n<p>Whereas software developers tend to care about the classes, functions, and processes they are writing.</p>\n<p>This mismatch in the thinking process leads to further misunderstanding among business and engineering teams.</p>\n<p>To understand the gravity of the problem let‚Äôs draw a typical feature request timeline, I went through:</p>\n<p>Six months into my job as a backend developer, I realized I need to understand better business requirements and design system flexible enough to adapt that frequency of change.</p>\n<p>Hence, <strong>Data Modelling</strong>.</p>\n<p>Data modeling aims to define:</p>\n<ul>\n<li><strong>The data contained in the database</strong> (e.g., entities: devices, profiles, products, carts, orders, wallets, etc.)</li>\n<li><strong>The relationships among data items</strong> (e.g., users can create products, profiles can add these products to their cart, etc.)</li>\n<li><strong>The constraints on data</strong> (e.g., at max only 30 products can be bought together, the user should not be able to use wallet credit if wallet balance becomes less than zero, etc.)</li>\n</ul>\n<p>Following data modeling guidelines gave me a clear understanding of business requirements and teams were able to understand and communicate themselves better.</p>\n<p><a name=\"separate-your-concerns\"></a></p>\n<hr>\n<h3>2. Separate Your Concerns</h3>\n<p>When I started backend development in Elanic, the problem we were trying to solve seemed natural. <em>It‚Äôs a social community engaged in buying and selling of lifestyle items.</em></p>\n<p>It took me seven consecutive sleepless nights to keep the servers running during our growth phase to understand there is nothing natural or straightforward about it.</p>\n<p>Once we stabilized the system to sustain the traffic, I realized the whole codebase is the unsustainable mesh of <strong>reads</strong> and <strong>writes</strong> operations.</p>\n<p>Next month went into a rewrite of the critical sections using proper abstractions ‚Äî separating read and write operations.</p>\n<p>Abstractions are the solutions to general problems. Consider + function. It is a solution to adding numbers in general. Without input arguments, it is quite useless.</p>\n<p>Applying these abstractions to a particular set of arguments is a solution to a specific problem.</p>\n<p>We often think of software as a solution to a particular issue, like accounting software is the solution to the problem of accounting. An e-commerce website is\na solution to selling online.</p>\n<p>But, <strong>it is a bit like kitchen being a solution to cooking</strong>. It doesn‚Äôt tell\nthe whole story. If you open the cabinet, you realize that preparing food is an\nextremely complicated process.</p>\n<p>It involves solving a lot of smaller problems, like cutting, heating, mixing\ningredients, etc. Our software is the same. It‚Äôs hundreds of solutions to lots\nof subproblems.</p>\n<p>As a software developer, when we develop a new system, <strong>our task is as involved\nas inventing a cuisine.</strong> Our tools are much more malleable than steel so that\nwe can iterate faster, but we still need to fill our arsenal with tools and\ndevelop techniques to select the right one and apply it in the right way.</p>\n<p><a name=\"leverage-rule-engines\"></a></p>\n<hr>\n<h3>3. Leverage Rule Engines</h3>\n<p>Once we decided to introduce voucher support in buy-flow of our application. To\ndo it faster I hardcoded the coupon code and validation logic within the\ncodebase. Next day onwards, the marketing team kept asking to change the coupon\nalmost every day, and we kept re-writing the same block of code instead of\nmoving forward and focusing on other features.</p>\n<p>We couldn‚Äôt properly test these deployments and ended up providing lousy user\nexperiences. Later on, similar kind of changes got introduced in deciding\ncommission, delivery charges, pickup charges, etc. Thankfully, my mentor,\n<a href=\"https://www.linkedin.com/in/abhishek-chauhan-625b80a/\">Abhishek Chauhan</a>\nintroduced me to rule engines right before I was reaching the limit of my\npatience.</p>\n<p><em>If you are not familiar with business rule engines, you may be wondering why\nyou would want to use one?</em></p>\n<p>In most software applications, complex rule processing often takes the form of\nnested if-else blocks of code which can be very difficult to interpret and to\nmaintain.</p>\n<p>If rules change <em>(which they always do)</em>, a developer must work with a business\nperson to define the new rule sets. He must then understand the existing\nimplementation and realize what‚Äôs happening to make the required modifications.\nThese changes must then be recompiled, tested, and redeployed.</p>\n<p>A business rules engine provides a means to separate the rules or logic of an\napplication from the remaining codebase. Separating these rules offer enormous\nbenefits.</p>\n<ul>\n<li><em>Business rule engines allow the declarative style of programming. Rules define\nwhat should happen, without describing how should it be happening. It makes\ncodebase much easier to read. Also, it becomes easier to make changes without\nintroducing bugs.</em></li>\n<li><em>We can describe these rules in an easy-to-understand language for business\npeople. It enables business people to validate and even modify rules without\ninvolving software developers.</em></li>\n<li><em>Also, you don‚Äôt need to go through. If your deployment process requires passing\neach line of code through a strict workflow of recompilation and testing,\nleveraging rule engines can be a huge time saver.</em></li>\n</ul>\n<p><a name=\"prioritize-software-testing\"></a></p>\n<hr>\n<h3>4. Prioritize Software Testing</h3>\n<p>In an early stage startup, feature requests tend to change so often that writing\nautomated tests takes a backfoot over manual testing and direct deployments.</p>\n<p>It‚Äôs not until too late that you realize that the trade-off has been too\nexpensive.</p>\n<p>I won‚Äôt suggest you write tests from the start <em>(ideally you should)</em>, but\nat-least write testable code.</p>\n<p>Some people write code in a way that is hard, or even impossible, to write a\ngood unit test for it. <strong>So, what makes the program hard to test?</strong> Let‚Äôs review\nsome bad-practices and code smells developers must avoid when writing testable\ncode.</p>\n<p><a name=\"uncontrolled-non-determinism-and-side-effects\"></a></p>\n<hr>\n<h4>Uncontrolled Non-Determinism and Side Effects</h4>\n<p>Methods with non-deterministic behavior and side-effects lead to deceptive, hard\nto understand, non-reusable, tightly coupled, and untestable code. They tend to\nhave destructive effects on your codebase.</p>\n<p>On the contrary, functions that are both deterministic and free of side-effects\nare much easier to test, reason about, and reuse to build more extensive\nprograms. In functional programming, these methods are called pure functions. To\ntest them you just need to pass required input arguments and check the result\nfor correctness.</p>\n<p><a name=\"impurity-is-toxic\"></a></p>\n<hr>\n<h4>Impurity is toxic</h4>\n<p>What makes code hard to test is hard-coded context driven values which may\nchange anytime. These impurities are hard to replace, override, or abstract away\nin some other way.</p>\n<p>If method <code class=\"language-text\">Foo()</code> depends on non-deterministic method <code class=\"language-text\">Bar()</code>, <code class=\"language-text\">Foo()</code>becomes\nnon-deterministic as well. Eventually, it ends up poisoning the entire system.\nMultiply all these problems by the size of a real-life software application, and\nyou‚Äôll find yourself entangled with a hard to maintain codebase, full of\nanti-patterns, secret dependencies, and all sorts of ugly and unpleasant things.</p>\n<p><a name=\"there-will-always-be-bugs\"></a></p>\n<hr>\n<h3>5. There Will Always Be Bugs</h3>\n<p>Straight out of college, I was a software developer striving for perfection. Any\nbug in my code frustrated me to the core. I wanted my work to be flawless, like\na clockwork, yet bugs appeared.</p>\n<p>It took me two years of professional experience to understand the reality:\n<strong>there will always be bugs.</strong></p>\n<p>I learned to change my attitude toward software development ‚Äî aiming for\nexcellence instead of perfection.</p>\n<p>I learned the phrase <strong>‚Äúget it right the first time‚Äù</strong> doesn‚Äôt exist in software\ndevelopment. No matter how much effort you make, bugs will always find a way to\ncrop up.</p>\n<p>Bugs pretty much can be defined as <strong>‚Äúthat didn‚Äôt cross our minds.‚Äù</strong></p>\n<p>If you want to ensure impeccable software quality, write less code that does\nless stuff, and then spend a lot of time honing that piece of code. However, it\nis not a realistic course of action to take.</p>\n<p>You need to understand that bugs are an unavoidable byproduct of software\ndevelopment. Instead of trying to eradicate software bugs once and for all, you\nshould focus on building a system that lets you quickly troubleshoot the\nproblems, fix the bugs, and deploy the fixes.</p>\n<p>Software developers need to understand ‚Äî the absence of bugs is merely one\nparameter for software‚Äôs success, but not even close to the most important one.</p>\n<p><strong>Usefulness.</strong> A useful software trumps a bug-free software anytime. The value\nof software depends far more upon the problem it solves than the quality by\nwhich it does so.</p>\n<p><a name=\"things-will-break\"></a></p>\n<hr>\n<h3>6. Things Will Break</h3>\n<p>Software development is a process. It‚Äôs always evolving, never really finished.\nToday your software sucks, my software sucks, we all are writing shitty\nsoftware. With bugs! But it‚Äôs shipping! Next time we will do better.</p>\n<p>Today you improved the <strong>application layer</strong> of your software system and\nresolved all the issues. Next day you will realize the problem in the <strong>database\nlayer</strong> has brought the whole system down. Once that is fixed, your\n<strong>infrastructure layer</strong> will disappoint you.</p>\n<p>The cycle will keep repeating. <strong>Things will always be breaking.</strong></p>\n<p>The unhappy stakeholders or customers will mock you for this. Validate their\nbelief that you‚Äôve let them down. <em>I agree what we wrote isn‚Äôt perfect. We won‚Äôt\nargue with you on that. Promise to look at their problems, and if possible fix\nit in next release.</em></p>\n<p>I have realized the best way to learn software design is to break it. It doesn‚Äôt\nmean that you should start ripping through a stable codebase and start rewriting\nis as an exercise.</p>\n<p>Start by breaking off a small piece. Do we even need this function? What happens\nif we remove this variable? Be curious about how it all works, and fix it.</p>\n<p>While learning to be good at software development, controlled destruction breeds\nconfidence. The most direct way to improve as a software developer is to be\nfearless when it comes to changing your code. Software developers who are afraid\nof a broken system are developers who will never mature into professionals.</p>\n<p><a name=\"setup-logging-and-error-handling-early\"></a></p>\n<hr>\n<h3>7. Setup Logging And Error Handling Early</h3>\n<p>When developing a new software system, one of the first things you must do is\nadd logging and error handling, because both are useful from the very beginning.</p>\n<p>For all software systems that are bigger than a handful of lines of code, you\nneed some way of knowing what happens in the program.</p>\n<p>Perhaps not when it is working as expected, but as soon as it doesn‚Äôt, you must\nbe able to see what‚Äôs happening.</p>\n<p>The same goes for error handling ‚Äî errors and exceptions happen in the beginning\ntoo, so the sooner you systematically handle them, the better.</p>\n<p><a name=\"it-will-take-longer-than-you-think\"></a></p>\n<hr>\n<h3>8. It Will Take Longer Than You Think</h3>\n<p><strong>Have you ever made a wrong estimate?</strong></p>\n<p>According to Daniel Kahneman‚Äôs research in the book <a href=\"https://amzn.to/2VVgk7y\">Thinking Fast and\nSlow</a>, there is a fair chance you would say yes.</p>\n<p>We are all bad at estimating. The reason why we are worse in estimates is that\nwe don‚Äôt seem to understand what they are. We don‚Äôt know what they are supposed\nto be. We don‚Äôt see why we do them. We don‚Äôt know how to do them.</p>\n<p>The problem with estimates is that they breed mistrust. Once you give an\nestimated deadline, it immediately transforms into a contract and commitment.\nThen you miss it!</p>\n<p><strong>Have you ever missed an estimate?</strong></p>\n<p>When you miss an estimate, the stakeholders assume that it was a commitment of\nsome kind and you are not trustworthy.</p>\n<p>Let me give you my example of making a terrible estimation:</p>\n<p>The early backend system of Elanic was written using PHP and MySQL. When I\ndiscussed with founders, they painted a beautiful picture of the scale we would\nbe handling.</p>\n<p>There is going to be a multitude of social interactions, buying &#x26; selling of\nitems, logistics tracking, feeds engagements, etc. We need to build a system\nwhich could handle such features and the scale of millions of users.</p>\n<p>My job was to migrate it to a new stack using NodeJS, MongoDB, and Elasticsearch\nalong with maintaining the current system. I brainstormed the new software\narchitecture and presented it.</p>\n<p>My boss asked how long is it going to take? Well, it is a few API calls to\nwrite. Four weeks and we would be ready to launch.</p>\n<p>We launched the new backend twelve months later. That was 12X of what was\nestimated.</p>\n<p>The problem seemed straightforward in the start. But I could not have known the\nissues without actually deep diving and trying to solve them.</p>\n<p>I learned it is effortless to give an estimate for a project deadline. But it is\ntough to hit it precisely.</p>\n<p>Even as of today most of my projects take <strong>three times longer</strong> than the time I\nforecast.</p>\n<p>There are so many external factors involved, communicating the requirements\neffectively, a simple merge turns out to be the cause of a catastrophic bug, or\nan API call doesn‚Äôt work as promised, etc. It is quite common to run into\nunexpected problems.</p>\n<p><a name=\"there-are-no-coincidences\"></a></p>\n<hr>\n<h3>9. There Are No Coincidences</h3>\n<p>Startups are really good at creating what I call <strong>‚ÄúFake Urgencies.‚Äù</strong> People\nwill come to you and say something like <em>‚Äúif we don‚Äôt do this by tomorrow, we\nare doomed.‚Äù</em></p>\n<p>As programmers, we‚Äôre under constant pressure to deliver code quickly. The most\nimportant lesson I learned in the last three years is ‚Äúhaste always makes\nwaste.‚Äù</p>\n<p>You should always take time to think about risks involved throughout the whole\nprocess.</p>\n<p><strong>Good software design is not an accident, it is the result of meticulous\nplanning and leveraging exceptional programming skills.</strong></p>\n<p>Never believe in coincidences, when you are developing a new feature, or fixing\nbugs. You committed a bug fix, and an independent service becomes unavailable?\nNot an accident.</p>\n<p>Ignoring such occurrences, and not spending time investigating the issue may\nbring the whole system down. In some cases make you lose your sleep and mental\nsanity.</p>\n<p><a name=\"conclusion\"></a></p>\n<hr>\n<h3>Conclusion</h3>\n<p>If you made it till this section, CONGRATULATIONS!. I thank you for your\ncommitment. I hope you feel less anxious after reading my experiences</p>\n<p>If I would like you to take in one lesson from my experiences in the post it‚Äôs\ngoing to be:</p>\n<p><em>Software development is hard work. A clear codebase and flexible software\narchitecture is no accident. Very few programs come out right the first time or\neven the third time. Remember this in moments of despair. If you find that\nbuilding reliable, scalable, and flexible software application is hard, it‚Äôs\nbecause it is hard.</em></p>\n<h3>We üíö your feedback</h3>\n<p>In this post, I shared the lessons I learned while working for an early stage\nstartup. If you have had such experiences while working as a software developer,\nComment Below! You can also share your feedback through\n<a href=\"https://github.com/vadelabs/nerdsden/issues\">Github</a> or Slack</p>\n<h3>References and Further Reading</h3>\n<ol>\n<li><a href=\"https://amzn.to/2AyCQKk\">MongoDB Data Modeling</a></li>\n</ol>","fields":{"slug":"9-software-design-lessons-i-learned-while-scaling-a-startup/","date":"January 06, 2019","tags":[{"id":"software-design","slug":"software-design","title":"Software Design"},{"id":"startup","slug":"startup","title":"Startup"},{"id":"software-development","slug":"software-development","title":"Software Development"},{"id":"best-practices","slug":"best-practices","title":"Best Practices"},{"id":"software-architecture","slug":"software-architecture","title":"Software Architecture"},{"id":"gyan","slug":"gyan","title":"Gyan"}]},"frontmatter":{"title":"9 Software Design Lessons I Learned While Scaling A Startup","author":"Pragyan Tripathi","summary":"Nine mantras for software developers to survive uncertainity and high frequency changes in a startup without losing their sleep over it.","metaDescription":"Are you a software developer in an early stage startup? Wish to learn key lessons in software engineering to design reliable software architecture? Click to find out more!","cover":{"children":[{"__typename":"ImageSharp","fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQT/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAeCWtcyGD//EABgQAAMBAQAAAAAAAAAAAAAAAAABEQIS/9oACAEBAAEFAlkaIdaiKf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAQEBAAAAAAAAAAAAAAAAABARIf/aAAgBAQAGPwLWV//EABgQAQEBAQEAAAAAAAAAAAAAAAEAESEx/9oACAEBAAE/IR6cJMOWo2cB9jzWZ//aAAwDAQACAAMAAAAQlC//xAAWEQADAAAAAAAAAAAAAAAAAAABECH/2gAIAQMBAT8QhX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgMAAwAAAAAAAAAAAAABABEhMUFRgZH/2gAIAQEAAT8QM8yTGH7EnALuIU+S5Sy0h33NuuuRigOT/9k=","aspectRatio":2.2222222222222223,"src":"/static/d15c1c7cc8b04e1c6d115176a7eef075/c3611/cover.jpg","srcSet":"/static/d15c1c7cc8b04e1c6d115176a7eef075/21eb9/cover.jpg 200w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/007d5/cover.jpg 400w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/c3611/cover.jpg 800w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/28dd4/cover.jpg 1200w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/0d0e5/cover.jpg 1600w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/d5388/cover.jpg 2400w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/5363e/cover.jpg 5551w","srcWebp":"/static/d15c1c7cc8b04e1c6d115176a7eef075/ca3ca/cover.webp","srcSetWebp":"/static/d15c1c7cc8b04e1c6d115176a7eef075/132d5/cover.webp 200w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/5f2a2/cover.webp 400w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/ca3ca/cover.webp 800w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/3c0bf/cover.webp 1200w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/0cbcf/cover.webp 1600w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/bd7b6/cover.webp 2400w,\n/static/d15c1c7cc8b04e1c6d115176a7eef075/1b486/cover.webp 5551w","sizes":"(max-width: 800px) 100vw, 800px"}}]}}}},"pageContext":{"slug":"9-software-design-lessons-i-learned-while-scaling-a-startup/"}}